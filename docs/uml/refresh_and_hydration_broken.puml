@startuml
title Refresh hydration flow - current implementation in MyRuntimeProvider.tsx

actor Browser
participant "MyRuntimeProvider.tsx" as PR
participant "useAssistantTransportRuntime" as RT
participant "FastAPI server.py\nGET /threads/<id>/messages" as API
participant "PERSISTED_AUI_MESSAGES\n(in-memory dict)" as AUI
participant "LangGraph graph\nget_state(thread_id)" as GRAPH
participant "mapBackendMessageToUi" as MAP
participant "threadRuntime.import(...)" as IMP
participant "Assistant UI render" as UI

Browser -> PR : Page refresh
PR -> RT : Create runtime with initialState\n(thread_id, user_id)
PR -> API : GET messages for thread

alt thread_id exists in PERSISTED_AUI_MESSAGES
  API -> AUI : lookup by thread_id
  AUI --> API : list of stored message JSON
  API --> PR : response: messages list
else fallback to LangGraph state
  API -> GRAPH : get_state(config for thread_id)
  GRAPH --> API : state.values["messages"]
  API --> PR : response: model_dump outputs\n(not assistant-ui shaped)
end alt

PR -> MAP : map each raw message\nand chain parentId linearly
MAP --> PR : cleaned messages\n(id, role, content parts, createdAt, parentId)

PR -> IMP : import cleaned messages into runtime
IMP -> UI : UI renders imported history

note right of MAP
mapBackendMessageToUi:
- role derived from msg.type or msg.role
- id coerced to string (fallback random)
- content normalized to list of parts
- parentId set to previous message id (linear chain)
end note

note right of API
GET /threads/<id>/messages is dual-mode:
1) returns persisted assistant-ui messages if present
2) otherwise returns LangGraph message dumps
(endpoints comment warns fallback is not assistant-ui shaped)
end note

@enduml
